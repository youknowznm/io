---
layout: default
title: Gulp
---

### Gulp是基于node.js串流的建构工具。取得来源文件作为输入后，Gulp串流到多个插件（plugins）取得输出的结果，而非像Grunt一样配置每个插件的输入和输出。

- 几个常用接口，详见[gulpjs](https://github.com/gulpjs/gulp/blob/master/docs/API.md)

```javascript
/*
创建任务
@param {string} name 任务名称，若要从命令行运行则不能出现空格
@param {=array.<string>} deps 依赖名称的数组
@param {=string} fn 依赖加载完成后的回调函数，一般返回在gulp对象上链式调用pipe方法之结果
*/
gulp.task(name [, deps] [, fn]) {}

/*
@param {string|array.<string>} globs 来源，可为glob格式或普通path
@param {=object} options 选项对象
*/
gulp.src(globs[, options]) {}

/*
@param {string} path 输出路径，一个任务可以输出至多个位置：标准版本和最小化的版本
@param {=object} options 选项对象
*/
gulp.dest(path[, options]) {}
```

- 几个常用的包：
    * 编译Sass (gulp-ruby-sass)
    * Autoprefixer (gulp-autoprefixer)
        - 根据设置的浏览器版本自动处理浏览器前缀，可解决部分兼容性问题
    * 压缩CSS (gulp-clean-css)
        - 减小CSS大小，并给引用url添加版本号避免缓存
    * JSHint (gulp-jshint)
        - 和JSLint类似的Javascript代码验证工具，可以检查代码并提供相关的改进意见
    * 拼接 (gulp-concat)
        - 合并JS文件以减少网络请求
    * 丑化(Uglify) (gulp-uglify)
        - 压缩javascript文件，减小文件大小
    * 图片压缩 (gulp-imagemin)
        - 压缩图片
    * 即时重整(LiveReload) (gulp-livereload)
        - 保存改动即刷新浏览器
    * 清理档案 (gulp-clean)
        - 清理目的地路径，防止已删除的原始文件残留
    * 图片快取，只有更改过的图片会进行压缩 (gulp-cache)
        - 仅压缩更改后的图片（？）
    * 更动通知 (gulp-notify)
        - 任务完成或出错时给出通知
        
#### 调试以上包的时候深切地感受到：百度二十分钟没有看Git上的文档一分钟管用……

### 终于好用了的gulpfile.js

```javascript
var gulp = require('gulp'),  
    sass = require('gulp-ruby-sass'),
    autoprefixer = require('gulp-autoprefixer'),
    minifycss = require('gulp-minify-css'),
    uglify = require('gulp-uglify'),
    imagemin = require('gulp-imagemin'),
    rename = require('gulp-rename'),
    clean = require('gulp-clean'),
    notify = require('gulp-notify'),
    livereload = require('gulp-livereload');

gulp.task('styles', function() {  
    return sass('css/style-updated.scss')
        .pipe(autoprefixer('last 2 version', 'safari 5', 'ios 6', 'android 4'))
        .pipe(gulp.dest('dest/styles'))
        .pipe(rename({ suffix: '.min' }))
        .pipe(minifycss())
        .pipe(gulp.dest('dest/styles'))
        .pipe(notify({ message: 'STYLES COMPLETE.' }));
});

gulp.task('scripts', function() {  
    return gulp.src('js/**/*.js')
        .pipe(uglify())
        .pipe(rename({suffix: '.min'}))
        .pipe(gulp.dest('dest/scripts'))
        .pipe(notify({ message: 'SCRIPTS COMPLETE.' }));
});

gulp.task('images', function() {  
    return gulp.src('img/*')
        .pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))
        .pipe(gulp.dest('dest/images'))
        .pipe(notify({ message: 'IMAGES COMPLETE.' }));
});

gulp.task('clean', function() {  
    return gulp.src(['dest/styles', 'dest/scripts', 'dest/images'], {read: false})
        .pipe(clean());
});

gulp.task('default', ['clean'], function() {  
    gulp.start('styles', 'scripts', 'images');
});

gulp.task('watch', function() {
    gulp.watch('css/*.scss', ['styles']);
    gulp.watch('js/*.js', ['scripts']);
    gulp.watch('img/*', ['images']);
//    // 建立即时重整伺服器
//    var server = livereload();
//    // 看守所有位在 dest/ 目录下的档案，一旦有更动，便进行重整
//    gulp.watch(['dest/**']).on('change', function(file) {
//    server.changed(file.path);
//    });
});
```